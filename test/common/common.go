package common

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/antihax/optional"

	openapi "github.com/openservicebrokerapi/osb-checker/autogenerated/go-client"
	. "github.com/openservicebrokerapi/osb-checker/config"
)

var (
	cli     *openapi.APIClient
	authCtx context.Context
)

func InitClientWithAuthCtx() error {
	// Initialize authCtx now
	switch CONF.Authentication.AuthType {
	case TypeNoauth:
		authCtx = context.Background()
		break
	case TypeBasicAuth:
		authCtx = context.WithValue(context.Background(), openapi.ContextBasicAuth, openapi.BasicAuth{
			UserName: CONF.Authentication.Username,
			Password: CONF.Authentication.Password,
		})
		break
	default:
		return fmt.Errorf("currently authentication (%s) is not supported!",
			CONF.Authentication.AuthType)
	}
	// Initialize HTTP client now
	cfg := openapi.NewConfiguration()
	cfg.BasePath = CONF.URL
	cli = openapi.NewAPIClient(cfg)

	return nil
}

// TODO: For provision, update and bind operation, testCatalogSchema should be
// called to assert the legality of parameters schema.
type SchemaOpts struct {
	ServiceID, PlanID  string
	Parameters         interface{}
	SchemaType, Action string
}

func testCatalogSchema(opt *SchemaOpts) error {
	catalog, _, err := cli.CatalogApi.CatalogGet(authCtx, CONF.APIVersion, &openapi.CatalogGetOpts{})
	if err != nil {
		return err
	}

	return parametersSchemaCheck(catalog, opt)
}

func parametersSchemaCheck(catalog openapi.Catalog, opt *SchemaOpts) error {
	svc := func(catalog openapi.Catalog) openapi.Service {
		for _, svc := range catalog.Services {
			if svc.Id == opt.ServiceID {
				return svc
			}
		}
		return openapi.Service{}
	}(catalog)
	plan := func(svc openapi.Service) openapi.Plan {
		for _, plan := range svc.Plans {
			if plan.Id == opt.PlanID {
				return plan
			}
		}
		return openapi.Plan{}
	}(svc)

	// If plan.Schemas is empty, then consider it would success no matter what
	// opt.Parameter is.
	emptySchemas := openapi.SchemasObject{}
	if reflect.DeepEqual(plan.Schemas, emptySchemas) {
		return nil
	}
	params := make(map[string]interface{})
	switch opt.SchemaType {
	case TypeServiceInstance:
		// If plan.Schemas.ServiceInstance is empty, then consider it would success no matter
		// what opt.Parameter is.
		instance := plan.Schemas.ServiceInstance
		emptyInsSchemas := openapi.ServiceInstanceSchemaObject{}
		if reflect.DeepEqual(instance, emptyInsSchemas) {
			return nil
		}
		if opt.Action == ActionCreate {
			// If instance.Create is empty, then consider it would success no matter
			// what opt.Parameter is.
			create := instance.Create
			emptyCreateSchemas := openapi.SchemaParameters{}
			if reflect.DeepEqual(create, emptyCreateSchemas) {
				return nil
			}
			params = create.Parameters
		} else {
			// If instance.Update is empty, then consider it would success no matter
			// what opt.Parameter is.
			update := instance.Update
			emptyUpdateSchemas := openapi.SchemaParameters{}
			if reflect.DeepEqual(update, emptyUpdateSchemas) {
				return nil
			}
			params = update.Parameters
		}
		break
	case TypeServiceBinding:
		// If plan.Schemas.ServiceBinding is empty, then consider it would success no matter
		// what opt.Parameter is.
		binding := plan.Schemas.ServiceBinding
		emptyBindSchemas := openapi.ServiceBindingSchemaObject{}
		if reflect.DeepEqual(binding, emptyBindSchemas) {
			return nil
		}
		// If binding.Create is empty, then consider it would success no matter what
		// opt.Parameter is.
		create := binding.Create
		emptyCreateSchemas := openapi.SchemaParameters{}
		if reflect.DeepEqual(create, emptyCreateSchemas) {
			return nil
		}
		params = create.Parameters
	}

	json.Marshal(params)
	return nil
}

func pollInstanceLastOperationStatus(instanceID string) error {
	return pollLastOperationStatus(instanceID, "")
}

func pollBindingLastOperationStatus(instanceID, bindingID string) error {
	return pollLastOperationStatus(instanceID, bindingID)
}

func pollLastOperationStatus(instanceID, bindingID string) error {
	var lastOperationStatus = "in progress"

	for i := 0; i < CONF.MaxPollingNum; i++ {
		if lastOperationStatus != "in progress" {
			break
		}
		fmt.Printf("\n%dth polling last operation...\n", i+1)

		body, resp, err := func() (openapi.LastOperationResource, *http.Response, error) {
			if bindingID == "" {
				return cli.ServiceInstancesApi.ServiceInstanceLastOperationGet(
					authCtx, CONF.APIVersion, instanceID,
					&openapi.ServiceInstanceLastOperationGetOpts{Operation: optional.NewString("deprovision")})
			}
			return cli.ServiceBindingsApi.ServiceBindingLastOperationGet(
				authCtx, CONF.APIVersion, instanceID, bindingID,
				&openapi.ServiceBindingLastOperationGetOpts{})
		}()
		if err != nil {
			return err
		}
		if resp.StatusCode != 200 {
			return fmt.Errorf("expected %v, got %v", 200, resp.StatusCode)
		}
		lastOperationStatus = body.State
		time.Sleep(time.Duration(CONF.PollingInterval) * time.Second)
	}
	if lastOperationStatus != "succeeded" {
		return fmt.Errorf("expected %v, got %v", "succeeded", lastOperationStatus)
	}

	return nil
}

func deepCopy(src, dst interface{}) error {
	srcByte, err := json.Marshal(src)
	if err != nil {
		return err
	}

	return json.Unmarshal(srcByte, dst)
}
